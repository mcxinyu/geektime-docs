site_name: Java并发编程实战

theme:
  name: material

  palette:
    # Palette toggle for light mode
    - media: "(prefers-color-scheme: light)"
      scheme: default
      toggle:
        icon: material/brightness-4
        name: Switch to dark mode

    # Palette toggle for dark mode
    - media: "(prefers-color-scheme: dark)"
      scheme: slate
      toggle:
        icon: material/brightness-7
        name: Switch to light mode

  features:
    - navigation.footer
    - content.action.edit
    - navigation.sections
    - content.code.copy

  icon:
    edit: material/pencil
    logo: material/console-line

extra_css:
  - static/css/extra.css

extra:
  homepage:
  version:
    provider: mike

copyright: Copyright &copy; 2024-Present zkep
repo_url: https://github.com/zkep/mygeektime

markdown_extensions:
  - attr_list
  - md_in_html
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.inlinehilite
  - pymdownx.snippets
  - pymdownx.superfences

nav:
   - 开篇词_你为什么需要学习并发编程_.md
  
   - 学习攻略_如何才能学好并发编程_.md
  
   - 01_可见性、原子性和有序性问题_并发编程Bug的源头.md
  
   - 02_Java内存模型_看Java如何解决可见性和有序性问题.md
  
   - 03_互斥锁（上）_解决原子性问题.md
  
   - 04_互斥锁（下）_如何用一把锁保护多个资源_.md
  
   - 05_一不小心就死锁了，怎么办_.md
  
   - 06_用“等待-通知”机制优化循环等待.md
  
   - 07_安全性、活跃性以及性能问题.md
  
   - 08_管程_并发编程的万能钥匙.md
  
   - 09_Java线程（上）_Java线程的生命周期.md
  
   - 10_Java线程（中）_创建多少线程才是合适的_.md
  
   - 11_Java线程（下）_为什么局部变量是线程安全的_.md
  
   - 12_如何用面向对象思想写好并发程序_.md
  
   - 13_理论基础模块热点问题答疑.md
  
   - 14_Lock和Condition（上）_隐藏在并发包中的管程.md
  
   - 15_Lock和Condition（下）_Dubbo如何用管程实现异步转同步_.md
  
   - 16_Semaphore_如何快速实现一个限流器_.md
  
   - 17_ReadWriteLock_如何快速实现一个完备的缓存_.md
  
   - 18_StampedLock_有没有比读写锁更快的锁_.md
  
   - 19_CountDownLatch和CyclicBarrier_如何让多线程步调一致_.md
  
   - 20_并发容器_都有哪些“坑”需要我们填_.md
  
   - 21_原子类_无锁工具类的典范.md
  
   - 22_Executor与线程池_如何创建正确的线程池_.md
  
   - 23_Future_如何用多线程实现最优的“烧水泡茶”程序_.md
  
   - 24_CompletableFuture_异步编程没那么难.md
  
   - 25_CompletionService_如何批量执行异步任务_.md
  
   - 26_Fork_Join_单机版的MapReduce.md
  
   - 27_并发工具类模块热点问题答疑.md
  
   - 28_Immutability模式_如何利用不变性解决并发问题_.md
  
   - 29_Copy-on-Write模式_不是延时策略的COW.md
  
   - 30_线程本地存储模式_没有共享，就没有伤害.md
  
   - 31_GuardedSuspension模式_等待唤醒机制的规范实现.md
  
   - 32_Balking模式_再谈线程安全的单例模式.md
  
   - 33_Thread-Per-Message模式_最简单实用的分工方法.md
  
   - 34_WorkerThread模式_如何避免重复创建线程_.md
  
   - 35_两阶段终止模式_如何优雅地终止线程_.md
  
   - 36_生产者-消费者模式_用流水线思想提高效率.md
  
   - 37_设计模式模块热点问题答疑.md
  
   - 38_案例分析（一）_高性能限流器GuavaRateLimiter.md
  
   - 39_案例分析（二）_高性能网络应用框架Netty.md
  
   - 40_案例分析（三）_高性能队列Disruptor.md
  
   - 41_案例分析（四）_高性能数据库连接池HiKariCP.md
  
   - 42_Actor模型_面向对象原生的并发模型.md
  
   - 43_软件事务内存_借鉴数据库的并发经验.md
  
   - 44_协程_更轻量级的线程.md
  
   - 45_CSP模型_Golang的主力队员.md
  
   - 结束语_十年之后，初心依旧.md
  
   - 结课测试_这些Java并发编程实战的知识你都掌握了吗_.md
  
   - 用户来信_真好，面试考到这些并发编程，我都答对了！.md
  
   - 3个用户来信_打开一个新的并发世界.md
  